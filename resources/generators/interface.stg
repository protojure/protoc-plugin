// -*- Mode:clojure;  -*-
//
// Copyright Â© 2019 State Street Bank and Trust Company.  All rights reserved
//
// SPDX-License-Identifier: Apache-2.0

messages(generic_namespace, namespace, enums, messages, requires, rpcs, server, client) ::=
<<
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package <generic_namespace>
;;;----------------------------------------------------------------------------------
(ns <generic_namespace>
  (:require [protojure.protobuf :as pb]
            [protojure.protobuf.serdes :refer :all]
            <requires:{dep|[<dep>]}; separator="\n">
            [clojure.set :as set]
            [clojure.spec.alpha :as s])
  (:import (com.google.protobuf
            CodedInputStream)))

<if(messages.values)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

<messages.values:{desc|<emit_declares(desc)>}; separator="\n">
<endif>

<if(enums.values)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

<enums.values:{desc|<emit_enum(desc)>}; separator="\n">
<endif>

<if(messages.values)>
<messages.values:{desc|<emit_oneof(desc.items)>}>
<endif>

<if(messages.values)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

<messages.values:{desc|<emit_message(namespace, desc)>}; separator="\n">
<endif>
>>

emit_oneof_fields(name, ofields) ::=
<<
<if(ofields)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; <name>'s oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-<name> [origkeyval]
  (cond
     <ofields.values:{of|<emit_replace_field(name, of)>}; separator="\n">
     :default origkeyval))

(defn write-<name> [<name> os]
  (let [field (first <name>)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         <ofields.values:{f|:<f.name> <emit_writer_field(f, "{:optimize false}", "v")>}; separator="\n">
         nil)))

(defn size-<name> [<name>]
  (let [field (first <name>)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      <ofields.values:{f|:<f.name> <emit_size_field(f, "{:optimize false}", "v")>}; separator="\n">
      0)))
<endif>
>>

emit_rpc_metadata(service, method, generic_namespace) ::=
<<
   {:pkg "<generic_namespace>" :service "<service.name>" :method "<method.name>" :method-fn <method.name>-dispatch :server-streaming <method.serverstreaming> :client-streaming <method.clientstreaming> :input <if(method.param.ns)><method.param.ns>/<endif>pb-><method.param.type> :output <if(method.retval.ns)><method.retval.ns>/<endif>new-<method.retval.type>}
>>

emit_rpc_method(service, method) ::=
<<
(defn- <method.name>-dispatch
  [ctx request]
  (<method.name> ctx request))
>>

emit_rpc(service, generic_namespace) ::=
<<
;-----------------------------------------------------------------------------
; GRPC <service.name>
;-----------------------------------------------------------------------------
(defprotocol Service
  <service.methods.values:{method|(<method.name> [this param])}; separator="\n">)

<service.methods.values:{desc|<emit_rpc_method(service, desc)>}; separator="\n">

(def ^:const rpc-metadata
  [<service.methods.values:{method|<emit_rpc_metadata(service, method, generic_namespace)>}; separator="\n">])

>>

emit_enum_label(desc) ::=
<<
<desc.tag> <desc.label>
>>

emit_enum(desc) ::=
<<
;-----------------------------------------------------------------------------
; <desc.name>
;-----------------------------------------------------------------------------
(def <desc.name>-val2label {
  <desc.items.values:{case|<emit_enum_label(case)>}; separator="\n">})

(def <desc.name>-label2val (set/map-invert <desc.name>-val2label))

(defn cis-><desc.name> [is]
  (let [val (.readEnum is)]
    (get <desc.name>-val2label val val)))

(defn- get-<desc.name> [value]
  {:pre [(or (int? value) (contains? <desc.name>-label2val value))]}
  (get <desc.name>-label2val value value))

(defn size-<desc.name> [tag options value]
  (size-Enum tag options (get-<desc.name> value)))

(defn write-<desc.name> [tag options value os]
  (write-Enum tag options (get-<desc.name> value) os))

>>

add_ns(type)              ::= "<if(type.ns)><type.ns>/<endif>"
emit_type(type, prefix)   ::= "<add_ns(type)><prefix><type.type>"
reader_type(type)         ::= "<if(type.embedded)><emit_type(type, \"ecis->\")><else><emit_type(type, \"cis->\")><endif>"
repeated_reader(type)     ::= "<if(type.packable)>packablerepeated tag<else>repeated<endif>"
reader_field(type)        ::= "(<if(type.repeated)>cis-><repeated_reader(type)> <endif><reader_type(type)> is)"
reader_map_field(type)    ::= "(cis->map ecis-><type.type> is)"
writer_type(op, desc)     ::= "<op>-<if(desc.type.embedded)>embedded<else><desc.type.type><endif>"
writer_repeated(op, desc) ::= "<if(desc.type.repeated)><op>-repeated <endif>"
writer_opt(desc, opt) ::= "<if(!(desc.ismap||desc.type.embedded||desc.ofields||desc.type.repeated))> <opt> <endif>"
writer_field(op, desc, opt, val) ::= "<if(desc.ismap)><op>-map new-<desc.type.type><else><writer_repeated(op, desc)><writer_type(op, desc)><endif> <if(desc.tag)><desc.tag><endif> <writer_opt(desc,opt)><if(val)><val><else>(:<desc.name> this)<endif>"
new_type(type)            ::= "<emit_type(type, \"new-\")>"
new_field(desc, type)     ::= "<if(type.repeated)>#(map <new_type(type)> %)<else><new_type(type)><endif>"
emit_reader_field(desc)   ::= "<desc.tag> [:<desc.name> <if(desc.ismap)><reader_map_field(desc.type)><else><reader_field(desc.type)><endif>]"
emit_writer_field(desc, opt, val) ::= "(<writer_field(\"write\", desc, opt, val)> os)"
emit_size_field(desc, opt, val) ::= "(<writer_field(\"size\", desc, opt, val)>)"
emit_new_field(desc)      ::= "(cond-> (contains? init :<desc.name>) (update :<desc.name> <new_field(desc, desc.type)>))"
emit_single_default(desc) ::= "<if(desc.type.default)>:<desc.name> <desc.type.default> <endif>"
emit_default(desc)        ::= "<if(desc.type.repeated)>:<desc.name> [] <else><emit_single_default(desc)><endif>"
emit_replace_field(name, of)          ::= "(get-in origkeyval [:<name> :<of.name>]) <if(of.isnested)>(update-in origkeyval [:<name> :<of.name>] new-<of.type.type>)<else>origkeyval<endif>"
emit_oneof_reader_field(name, desc)   ::= "<desc.tag> [:<name> {:<desc.name> <if(desc.ismap)><reader_map_field(desc.type)><else><reader_field(desc.type)><endif>}]"
process_reader_field(field)           ::= "<if(field.ofields)><field.ofields.values:{f|<emit_oneof_reader_field(field.name, f)><\n>}><elseif(!field.oindex)><emit_reader_field(field)><\n><endif>"
emit_oneof(items)                     ::= "<items.values:{field|<emit_oneof_fields(field.name, field.ofields)>}>"
emit_specname(ns,desc,field)          ::= ":<ns>.<desc.name>/<field.name>"
emit_maybe_specname(ns,desc,field)    ::= "<if(field.type.spec)><emit_specname(ns,desc,field)> <endif>"
emit_maybe_repeatspec(ns,desc,field)  ::= "<if(field.type.repeated)>(s/every <endif><field.type.spec><if(field.type.repeated)>)<endif>"
emit_field_spec(ns,desc,field)        ::= "<if(field.type.spec)>(s/def <emit_specname(ns,desc,field)> <emit_maybe_repeatspec(ns,desc,field)>)<endif>"

emit_declares(desc) ::=
<<
(declare cis-><desc.name>)
(declare ecis-><desc.name>)
(declare new-<desc.name>)
>>

emit_message(namespace, desc) ::=
<<
;-----------------------------------------------------------------------------
; <desc.name>
;-----------------------------------------------------------------------------
(defrecord <desc.name> [<desc.items.values:{field|<field.name>}; separator=" ">]
  pb/Writer

  (serialize [this os]
    <desc.items.values:{field|<emit_writer_field(field,"{:optimize true}",false)>}; separator="\n">)

  (length [this]
    (reduce + [<desc.items.values:{field|<emit_size_field(field,"{:optimize true}",false)>}; separator="\n">])))

<desc.items.values:{field|<emit_field_spec(namespace, desc, field)>}; separator="\n">
(s/def ::<desc.name>-spec (s/keys :opt-un [<desc.items.values:{field|<emit_maybe_specname(namespace, desc,field)>}>]))
(def <desc.name>-defaults {<desc.items.values:{field|<emit_default(field)>}>})

(defn cis-><desc.name>
  "CodedInputStream to <desc.name>"
  [is]
  (->\> (tag-map <desc.name>-defaults
         (fn [tag index]
             (case index
               <desc.items.values:{field|<process_reader_field(field)>}>
               [index (cis->undefined tag is)]))
         is)
        (map-><desc.name>)))

(defn ecis-><desc.name>
  "Embedded CodedInputStream to <desc.name>"
  [is]
  (cis->embedded cis-><desc.name> is))

(defn new-<desc.name>
  "Creates a new instance from a map, similar to map-><desc.name> except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::<desc.name>-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::<desc.name>-spec init))))]}
  (-> (merge <desc.name>-defaults init)
      <desc.nested.values:{field|<emit_new_field(field)>}; separator="\n">
<if(desc.ofields)>
      <desc.ofields.values:{field|(convert-<field.name>)}; separator="\n">
<endif>
      (map-><desc.name>)))

(defn pb-><desc.name>
  "Protobuf to <desc.name>"
  [input]
  (-> input
      CodedInputStream/newInstance
      cis-><desc.name>))

>>

grpc-client(generic_namespace, namespace, enums, messages, requires, rpcs) ::=
<<
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; GRPC <namespace> Client Implementation
;;;----------------------------------------------------------------------------------
(ns <namespace>.client
  (:require [<generic_namespace> :refer :all]
            <requires:{dep|[<dep>]}; separator="\n">
            [clojure.core.async :as async]
            [protojure.grpc.client.utils :refer [send-unary-params invoke-unary]]
            [promesa.core :as p]
            [protojure.grpc.client.api :as grpc]))

<rpcs.values:{method_desc|<emit_rpc_client(method_desc, generic_namespace)>}; separator="\n">

>>

grpc-server(generic_namespace, namespace, enums, messages, requires, rpcs) ::=
<<
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; GRPC <namespace> Service Implementation
;;;----------------------------------------------------------------------------------
(ns <namespace>.server
  (:require [<generic_namespace> :refer :all]
            <requires:{dep|[<dep>]}; separator="\n">))

<rpcs.values:{method_desc|<emit_rpc(method_desc, generic_namespace)>}; separator="\n">
>>

emit_param_map(generic_namespace, rpcs) ::=
<<
(def param-map
  {:<generic_namespace> {
    <rpcs.values:{
      method_desc|<service_param(method_desc, generic_namespace)>}; separator="\n">}})
>>

emit_rpc_client(service, ns) ::=
<<
;-----------------------------------------------------------------------------
; GRPC Client Implementation
;-----------------------------------------------------------------------------

<service.methods.values:{method_desc|<emit_rpc_client_method(method_desc, service, ns)>}; separator="\n">
>>

emit_rpc_client_method(method, service, ns) ::=
<<
(defn <method.name>
  [client params<if(method.serverstreaming)> reply<endif>]
  (let [<if(!method.clientstreaming)>input (async/chan 1)<\n>        <endif><if(!method.serverstreaming)>output (async/chan 1)<\n>        <endif>desc {:service "<ns>.<service.name>"
              :method  "<method.name>"
              :input   {:f <if(method.param.ns)><method.param.ns><else><ns><endif>/new-<method.param.type> :ch <if(method.clientstreaming)>params<else>input<endif>}
              :output  {:f <if(method.retval.ns)><method.retval.ns><else><ns><endif>/pb-><method.retval.type> :ch <if(method.serverstreaming)>reply<else>output<endif>}}]
    <if(!method.clientstreaming)>
    (-> (send-unary-params input params)
        (p/then (fn [_] <else>    <endif><if(method.serverstreaming)>(grpc/invoke client desc)<else>(invoke-unary client desc output)<endif><if(method.clientstreaming)>))<else>)))))<endif>

>>

service_param(service, ns) ::=
<<
:<service.name> {
 <service.methods.values:{method_desc|<method_param(method_desc, ns)>}; separator="\n">}
>>

method_param(method, ns) ::=
<<
:<method.name> {:param {"<method.param.type>" <if(method.param.ns)><method.param.ns><else><ns><endif>/new-<method.param.type>} :retval {"<method.retval.type>" <if(method.retval.ns)><method.retval.ns><else><ns><endif>/pb-><method.retval.type>} :client-streaming <method.clientstreaming> :server-streaming <method.serverstreaming>}
>>
