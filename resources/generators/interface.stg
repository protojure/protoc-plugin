// -*- Mode:clojure;  -*-
//
// Copyright Â© 2019 State Street Bank and Trust Company.  All rights reserved
//
// SPDX-License-Identifier: Apache-2.0

messages(package, generic_namespace, namespace, enums, messages, requires, rpcs, server, client) ::=
<<
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package <namespace>
;;;----------------------------------------------------------------------------------
(ns <namespace>
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            <requires:{dep|[<dep>]}; separator="\n">
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

<if(messages.values)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

<messages.values:{desc|<emit_declares(desc)>}; separator="\n">
<endif>

<if(enums.values)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

<enums.values:{desc|<emit_enum(desc)>}; separator="\n">
<endif>

<if(messages.values)>
<messages.values:{desc|<emit_oneof(desc.items)>}>
<endif>

<if(messages.values)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

<messages.values:{desc|<emit_message(namespace, desc)>}; separator="\n">
<endif>
>>

emit_oneof_fields(name, oparentname, ofields) ::=
<<
<if(ofields)>
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; <oparentname>-<name>'s oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-<oparentname>-<name> [origkeyval]
  (cond
     <ofields.values:{of|<emit_replace_field(name, of)>}; separator="\n">
     :default origkeyval))

(defn write-<oparentname>-<name> [<name> os]
  (let [field (first <name>)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         <ofields.values:{f|:<f.name> <emit_writer_field(f, "{:optimize false}", "v")>}; separator="\n">
         nil)))

<endif>
>>

emit_rpc_metadata(package, service, method) ::=
<<
   {:pkg "<package>" :service "<service.name>" :method "<method.name>" :method-fn <method.name>-dispatch :server-streaming <method.serverstreaming> :client-streaming <method.clientstreaming> :input <if(method.param.ns)><method.param.ns>/<endif>pb-><method.param.type> :output <if(method.retval.ns)><method.retval.ns>/<endif>new-<method.retval.type>}
>>

emit_rpc_method(service, method) ::=
<<
(defn- <method.name>-dispatch
  [ctx request]
  (<method.name> ctx request))
>>

emit_rpc(service, package, generic_namespace) ::=
<<
;-----------------------------------------------------------------------------
; GRPC <service.name>
;-----------------------------------------------------------------------------
(defprotocol Service
  <service.methods.values:{method|(<method.name> [this param])}; separator="\n">)

(def <service.name>-service-name "<package>.<service.name>")

<service.methods.values:{desc|<emit_rpc_method(service, desc)>}; separator="\n">

(def ^:const rpc-metadata
  [<service.methods.values:{method|<emit_rpc_metadata(package, service, method)>}; separator="\n">])

>>

emit_enum_label(desc) ::=
<<
<desc.tag> <desc.label>
>>

emit_enum(desc) ::=
<<
;-----------------------------------------------------------------------------
; <desc.name>
;-----------------------------------------------------------------------------
(def <desc.name>-default <first(desc.items.values).label>)

(def <desc.name>-val2label {
  <desc.items.values:{case|<emit_enum_label(case)>}; separator="\n">})

(def <desc.name>-label2val (set/map-invert <desc.name>-val2label))

(defn cis-><desc.name> [is]
  (let [val (serdes.core/cis->Enum is)]
    (get <desc.name>-val2label val val)))

(defn- get-<desc.name> [value]
  {:pre [(or (int? value) (contains? <desc.name>-label2val value))]}
  (get <desc.name>-label2val value value))

(defn write-<desc.name>
  ([tag value os] (write-<desc.name> tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-<desc.name> value) os)))

>>

builtin_prefix(type)      ::= "<if(type.builtin)>serdes.core/<endif>"
add_ns(type)              ::= "<if(type.ns)><type.ns>/<endif>"
emit_type(type, prefix)   ::= "<if(type.builtin)><builtin_prefix(type)><else><add_ns(type)><endif><prefix><type.type>"
reader_type(type)         ::= "<if(type.embedded)><emit_type(type, \"ecis->\")><else><emit_type(type, \"cis->\")><endif>"
repeated_reader(type)     ::= "<if(type.packable)>packablerepeated tag<else>repeated<endif>"
reader_field(type)        ::= "(<if(type.repeated)>serdes.complex/cis-><repeated_reader(type)> <endif><reader_type(type)> is)"
reader_map_field(type)    ::= "(serdes.complex/cis->map ecis-><type.type> is)"
writer_type(desc)         ::= "<if(desc.type.embedded)>serdes.core/write-embedded<else><emit_type(desc.type, \"write-\")><endif>"
writer_repeated(desc)     ::= "<if(desc.type.repeated)>serdes.complex/write-repeated <endif>"
writer_opt(desc, opt)     ::= "<if(!(desc.ismap||desc.type.embedded||desc.ofields||desc.type.repeated))> <opt> <endif>"
writer_field(desc, opt, val) ::= "<if(desc.ismap)>serdes.complex/write-map new-<desc.type.type><else><writer_repeated(desc)><writer_type(desc)><endif> <if(desc.tag)><desc.tag><endif> <writer_opt(desc,opt)><if(val)><val><else>(:<desc.name> this)<endif>"
new_type(type)            ::= "<emit_type(type, \"new-\")>"
new_field(desc, type)     ::= "<if(type.repeated)>#(map <new_type(type)> %)<else><new_type(type)><endif>"
emit_reader_field(desc)   ::= "<desc.tag> [:<desc.name> <if(desc.ismap)><reader_map_field(desc.type)><else><reader_field(desc.type)><endif>]"
emit_writer_field(desc, opt, val) ::= "(<writer_field(desc, opt, val)> os)"
emit_new_field(desc)      ::= "(cond-> (some? (get init :<desc.name>)) (update :<desc.name> <new_field(desc, desc.type)>))"
emit_single_default(desc) ::= "<if(desc.type.default)>:<desc.name> <desc.type.default> <endif>"
emit_default(desc)        ::= "<if(desc.type.repeated)>:<desc.name> [] <else><emit_single_default(desc)><endif>"
emit_replace_field(name, of)          ::= "(get-in origkeyval [:<name> :<of.name>]) <if(of.isnested)>(update-in origkeyval [:<name> :<of.name>] <emit_type(of.type, \"new-\")>)<else>origkeyval<endif>"
emit_oneof_reader_field(name, desc)   ::= "<desc.tag> [:<name> {:<desc.name> <if(desc.ismap)><reader_map_field(desc.type)><else><reader_field(desc.type)><endif>}]"
process_reader_field(field)           ::= "<if(field.ofields)><field.ofields.values:{f|<emit_oneof_reader_field(field.name, f)><\n>}><elseif(!field.oindex)><emit_reader_field(field)><\n><endif>"
emit_oneof(items)                     ::= "<items.values:{field|<emit_oneof_fields(field.name, field.oparentname, field.ofields)>}>"
emit_specname(ns,desc,field)          ::= ":<ns>.<desc.name>/<field.name>"
emit_maybe_specname(ns,desc,field)    ::= "<if(field.type.spec)><emit_specname(ns,desc,field)> <endif>"
emit_maybe_repeatspec(ns,desc,field)  ::= "<if(field.type.repeated)>(s/every <endif><field.type.spec><if(field.type.repeated)>)<endif>"
emit_field_spec(ns,desc,field)        ::= "<if(field.type.spec)>(s/def <emit_specname(ns,desc,field)> <emit_maybe_repeatspec(ns,desc,field)>)<endif>"

emit_declares(desc) ::=
<<
(declare cis-><desc.name>)
(declare ecis-><desc.name>)
(declare new-<desc.name>)
>>

emit_symbol(desc) ::= "<desc.name>-record"
emit_record_type(namespace, desc) ::= "<namespace>.<desc.name>"

emit_message(namespace, desc) ::=
<<
;-----------------------------------------------------------------------------
; <desc.name>
;-----------------------------------------------------------------------------
(defrecord <emit_symbol(desc)> [<desc.items.values:{field|<field.name>}; separator=" ">]
  pb/Writer
  (serialize [this os]
    <desc.items.values:{field|<emit_writer_field(field,"{:optimize true}",false)>}; separator="\n">)
  pb/TypeReflection
  (gettype [this]
    "<emit_record_type(namespace, desc)>"))

<desc.items.values:{field|<emit_field_spec(namespace, desc, field)>}; separator="\n">
(s/def ::<desc.name>-spec (s/keys :opt-un [<desc.items.values:{field|<emit_maybe_specname(namespace, desc,field)>}>]))
(def <desc.name>-defaults {<desc.items.values:{field|<emit_default(field)>}>})

(defn cis-><desc.name>
  "CodedInputStream to <desc.name>"
  [is]
  (->\> (tag-map <desc.name>-defaults
         (fn [tag index]
             (case index
               <desc.items.values:{field|<process_reader_field(field)>}>
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map-><emit_symbol(desc)>)))

(defn ecis-><desc.name>
  "Embedded CodedInputStream to <desc.name>"
  [is]
  (serdes.core/cis->embedded cis-><desc.name> is))

(defn new-<desc.name>
  "Creates a new instance from a map, similar to map-><desc.name> except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::<desc.name>-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::<desc.name>-spec init))))]}
  (-> (merge <desc.name>-defaults init)
      <desc.nested.values:{field|<emit_new_field(field)>}; separator="\n">
<if(desc.ofields)>
      <desc.ofields.values:{field|(convert-<desc.name>-<field.name>)}; separator="\n">
<endif>
      (map-><emit_symbol(desc)>)))

(defn pb-><desc.name>
  "Protobuf to <desc.name>"
  [input]
  (cis-><desc.name> (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record <desc.name>-meta {:type "<emit_record_type(namespace, desc)>" :decoder pb-><desc.name>})

>>

grpc-client(package, generic_namespace, namespace, enums, messages, requires, rpcs) ::=
<<
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; GRPC <namespace> Client Implementation
;;;----------------------------------------------------------------------------------
(ns <namespace>.client
  (:require [<generic_namespace> :refer :all]
            <requires:{dep|[<dep>]}; separator="\n">
            [clojure.core.async :as async]
            [protojure.grpc.client.utils :refer [send-unary-params invoke-unary]]
            [promesa.core :as p]
            [protojure.grpc.client.api :as grpc]))

<rpcs.values:{method_desc|<emit_rpc_client(method_desc, package, generic_namespace)>}; separator="\n">

>>

grpc-server(package, generic_namespace, namespace, enums, messages, requires, rpcs) ::=
<<
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; GRPC <namespace> Service Implementation
;;;----------------------------------------------------------------------------------
(ns <namespace>.server
  (:require [<generic_namespace> :refer :all]
            <requires:{dep|[<dep>]}; separator="\n">))

<rpcs.values:{method_desc|<emit_rpc(method_desc, package, generic_namespace)>}; separator="\n">
>>

emit_param_map(generic_namespace, rpcs) ::=
<<
(def param-map
  {:<generic_namespace> {
    <rpcs.values:{
      method_desc|<service_param(method_desc, generic_namespace)>}; separator="\n">}})
>>

emit_rpc_client(service, package, ns) ::=
<<
;-----------------------------------------------------------------------------
; GRPC Client Implementation
;-----------------------------------------------------------------------------

(def <service.name>-service-name "<package>.<service.name>")

<service.methods.values:{method_desc|<emit_rpc_client_method(method_desc, service, package, ns)>}; separator="\n">
>>

emit_rpc_client_method(method, service, package, ns) ::=
<<
(defn <method.name>
  ([client params<if(method.serverstreaming)> reply<endif>] (<method.name> client {} params<if(method.serverstreaming)> reply<endif>))
  ([client metadata params<if(method.serverstreaming)> reply<endif>]
  (let [<if(!method.clientstreaming)>input (async/chan 1)<\n>        <endif><if(!method.serverstreaming)>output (async/chan 1)<\n>        <endif>desc {:service "<package>.<service.name>"
              :method  "<method.name>"
              :input   {:f <if(method.param.ns)><method.param.ns><else><ns><endif>/new-<method.param.type> :ch <if(method.clientstreaming)>params<else>input<endif>}
              :output  {:f <if(method.retval.ns)><method.retval.ns><else><ns><endif>/pb-><method.retval.type> :ch <if(method.serverstreaming)>reply<else>output<endif>}
              :metadata metadata}]
    <if(!method.clientstreaming)>
    (-> (send-unary-params input params)
        (p/then (fn [_] <else>    <endif><if(method.serverstreaming)>(grpc/invoke client desc)<else>(invoke-unary client desc output)<endif><if(method.clientstreaming)>)))<else>))))))<endif>

>>

service_param(service, ns) ::=
<<
:<service.name> {
 <service.methods.values:{method_desc|<method_param(method_desc, ns)>}; separator="\n">}
>>

method_param(method, ns) ::=
<<
:<method.name> {:param {"<method.param.type>" <if(method.param.ns)><method.param.ns><else><ns><endif>/new-<method.param.type>} :retval {"<method.retval.type>" <if(method.retval.ns)><method.retval.ns><else><ns><endif>/pb-><method.retval.type>} :client-streaming <method.clientstreaming> :server-streaming <method.serverstreaming>}
>>
